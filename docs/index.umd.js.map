{"version":3,"file":"index.umd.js","sources":["../src/index.mjs"],"sourcesContent":["/**\n * Uses Intersection Observer to monitor the page location of a series of\n * elements for scrollytelling.\n *\n * @param {object} options\n * @param {Element} [options.container] Optionally pass in what should be\n * considered the containing element of all the scenes - this gets added to the\n * Intersection Observer instance and additionally fires its own events\n * @param {Number} [options.offset] How far from the top/bottom of the viewable\n * area to trigger enters/exits of scenes, represented as a value between\n * 0 and 1\n * @param {Element[]} options.scenes An array of all the Elements to be\n * considered scenes of this Scroller\n * @property {IntersectionObserver|null} observer Once initialized, a reference\n * to the Scroller's instance of IntersectionObserver\n * @example\n *\n * import Scroller from '@newswire/scroller';\n *\n * const scroller = new Scroller({\n *   scenes: document.querySelectorAll('.scenes')\n * });\n *\n * scroller.init();\n */\nclass Scroller {\n\tconstructor({ container, offset = 0.5, scenes }) {\n\t\t// internal\n\t\tconst fuzz = 0.01;\n\n\t\t// public\n\t\tthis.observer = null;\n\n\t\t// private\n\t\tthis.all_ = {};\n\t\tthis.container_ = container;\n\t\tthis.offset_ = offset + fuzz;\n\t\tthis.previousOffset_ = 0;\n\t\tthis.scenes_ = scenes;\n\t}\n\n\t/**\n\t * Adds a callback to the queue of a given event listener.\n\t *\n\t * @param {string} type Name of the event\n\t * @param {Function} handler Callback function added to the listener\n\t * @returns {void}\n\t * @example\n\t *\n\t * const scroller = new Scroller({\n\t *   scenes: document.querySelectorAll('.scenes')\n\t * });\n\t *\n\t * const fn = (...) => {...};\n\t *\n\t * // adds callback to listener\n\t * scroller.on('scene:enter', fn);\n\t */\n\ton(type, handler) {\n\t\t(this.all_[type] || (this.all_[type] = [])).push(handler);\n\t}\n\n\t/**\n\t * Removes a callback from the queue of a given event listener.\n\t *\n\t * @param {string} type Name of the event\n\t * @param {Function} handler Callback function removed from the listener\n\t * @returns {void}\n\t * @example\n\t *\n\t * const scroller = new Scroller({\n\t *   scenes: document.querySelectorAll('.scenes')\n\t * });\n\t *\n\t * const fn = (...) => {...};\n\t *\n\t * // adds callback to listener\n\t * scroller.on('scene:enter', fn);\n\t *\n\t * // removes callback from listener\n\t * scroller.off('scene:enter', fn);\n\t */\n\toff(type, handler) {\n\t\tif (this.all_[type]) {\n\t\t\tthis.all_[type].splice(this.all_[type].indexOf(handler) >>> 0, 1);\n\t\t}\n\t}\n\n\t/**\n\t * Sends a payload to all callback functions listening for a given event.\n\t *\n\t * @private\n\t * @param {string} type Name of the event\n\t * @param {*} [evt] Data to be sent to each callback attached to the listener, optional\n\t * @returns {void}\n\t */\n\temit_(type, evt) {\n\t\t(this.all_[type] || []).slice().map((handler) => {\n\t\t\thandler(evt);\n\t\t});\n\t}\n\n\t/**\n\t * Initializes a Scroller's IntersectionObserver on a page and begins sending\n\t * any intersection events that occur.\n\t *\n\t * @returns {void}\n\t * @example\n\t *\n\t * const scroller = new Scroller({\n\t *   scenes: document.querySelectorAll('.scenes')\n\t * });\n\t *\n\t * scroller.init();\n\t */\n\tinit() {\n\t\tconst observed = [];\n\n\t\tthis.observer = new IntersectionObserver(\n\t\t\t(entries) => {\n\t\t\t\tconst isScrollingDown = this.getDirection_();\n\n\t\t\t\tentries.forEach((entry) => {\n\t\t\t\t\tconst element = entry.target;\n\n\t\t\t\t\tconst payload = {\n\t\t\t\t\t\tbounds: entry.boundingClientRect,\n\t\t\t\t\t\telement,\n\t\t\t\t\t\tindex: observed.indexOf(element),\n\t\t\t\t\t\tisScrollingDown,\n\t\t\t\t\t};\n\n\t\t\t\t\tconst prefix = element === this.container_ ? 'container' : 'scene';\n\n\t\t\t\t\tif (entry.isIntersecting) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Container enter event. Fires whenever the container begins intersecting.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @event Scroller#container:enter\n\t\t\t\t\t\t * @type {object}\n\t\t\t\t\t\t * @property {DOMRectReadOnly} bounds The bounds of the active element\n\t\t\t\t\t\t * @property {Element} element The element that intersected\n\t\t\t\t\t\t * @property {number} index This is always -1 on the container\n\t\t\t\t\t\t * @property {boolean} isScrollingDown Whether the user triggered this element\n\t\t\t\t\t\t * while scrolling down or not\n\t\t\t\t\t\t */\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Scene enter event. Fires whenever a scene begins intersecting.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @event Scroller#scene:enter\n\t\t\t\t\t\t * @type {object}\n\t\t\t\t\t\t * @property {DOMRectReadOnly} bounds The bounds of the active element\n\t\t\t\t\t\t * @property {Element} element The element that intersected\n\t\t\t\t\t\t * @property {number} index The index of the active element\n\t\t\t\t\t\t * @property {boolean} isScrollingDown Whether the user triggered this element\n\t\t\t\t\t\t * while scrolling down or not\n\t\t\t\t\t\t */\n\t\t\t\t\t\tthis.emit_(`${prefix}:enter`, payload);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Container exit event. Fires whenever the container has exited.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @event Scroller#container:exit\n\t\t\t\t\t\t * @type {object}\n\t\t\t\t\t\t * @property {DOMRectReadOnly} bounds The bounds of the exiting element\n\t\t\t\t\t\t * @property {Element} element The element that exited\n\t\t\t\t\t\t * @property {number} index This is always -1 on the container\n\t\t\t\t\t\t * @property {boolean} isScrollingDown Whether the user triggering the exit\n\t\t\t\t\t\t * while scrolling down or not\n\t\t\t\t\t\t */\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Scene enter event. Fires whenever a scene has exited.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * @event Scroller#scene:exit\n\t\t\t\t\t\t * @type {object}\n\t\t\t\t\t\t * @property {DOMRectReadOnly} bounds The bounds of the exiting element\n\t\t\t\t\t\t * @property {Element} element The element that exited\n\t\t\t\t\t\t * @property {number} index The index of the exiting element\n\t\t\t\t\t\t * @property {boolean} isScrollingDown Whether the user triggering the exit\n\t\t\t\t\t\t * while scrolling down or not\n\t\t\t\t\t\t */\n\t\t\t\t\t\tthis.emit_(`${prefix}:exit`, payload);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t{\n\t\t\t\trootMargin: `${-100 * (1 - this.offset_)}% 0px ${-100 * this.offset_}%`,\n\t\t\t},\n\t\t);\n\n\t\tfor (let i = 0; i < this.scenes_.length; i++) {\n\t\t\tconst item = this.scenes_[i];\n\n\t\t\tobserved.push(item);\n\t\t\tthis.observer.observe(item);\n\t\t}\n\n\t\t// a container is not required, but if provided we'll track it\n\t\tif (this.container_) this.observer.observe(this.container_);\n\n\t\t/**\n\t\t * Init event. Fires once Scroller has finished setting up.\n\t\t *\n\t\t * @event Scroller#init\n\t\t */\n\t\tthis.emit_('init');\n\t}\n\n\t/**\n\t * Determines whether the page was scrolling up or down when an intersection\n\t * event is triggered. Keeps track of direction via storage of the previous\n\t * pageYOffset.\n\t *\n\t * @private\n\t * @returns {boolean} If true, the page was scrolling down\n\t */\n\tgetDirection_() {\n\t\tconst currentOffset = window.pageYOffset;\n\n\t\tconst isScrollingDown = currentOffset > this.previousOffset_;\n\t\tthis.previousOffset_ = currentOffset;\n\n\t\treturn isScrollingDown;\n\t}\n}\n\nexport default Scroller;\n"],"names":["container","offset","scenes","this","observer","all_","container_","offset_","previousOffset_","scenes_","on","type","handler","push","off","splice","indexOf","emit_","evt","slice","map","init","observed","IntersectionObserver","entries","isScrollingDown","_this","getDirection_","forEach","entry","element","target","payload","bounds","boundingClientRect","index","prefix","isIntersecting","rootMargin","i","length","item","observe","currentOffset","window","pageYOffset"],"mappings":"mMA0BC,kBAAcA,IAAAA,cAAWC,OAAAA,aAAS,KAAKC,IAAAA,OAKtCC,KAAKC,SAAW,KAGhBD,KAAKE,EAAO,GACZF,KAAKG,EAAaN,EAClBG,KAAKI,EAAUN,EARF,IASbE,KAAKK,EAAkB,EACvBL,KAAKM,EAAUP,6BAoBhBQ,GAAA,SAAGC,EAAMC,IACPT,KAAKE,EAAKM,KAAUR,KAAKE,EAAKM,GAAQ,KAAKE,KAAKD,MAuBlDE,IAAA,SAAIH,EAAMC,GACLT,KAAKE,EAAKM,IACbR,KAAKE,EAAKM,GAAMI,OAAOZ,KAAKE,EAAKM,GAAMK,QAAQJ,KAAa,EAAG,MAYjEK,EAAA,SAAMN,EAAMO,IACVf,KAAKE,EAAKM,IAAS,IAAIQ,QAAQC,IAAI,SAACR,GACpCA,EAAQM,QAiBVG,KAAA,sBACOC,EAAW,GAEjBnB,KAAKC,SAAW,IAAImB,qBACnB,SAACC,GACA,IAAMC,EAAkBC,EAAKC,IAE7BH,EAAQI,QAAQ,SAACC,GAChB,IAAMC,EAAUD,EAAME,OAEhBC,EAAU,CACfC,OAAQJ,EAAMK,mBACdJ,QAAAA,EACAK,MAAOb,EAASN,QAAQc,GACxBL,gBAAAA,GAGKW,EAASN,IAAYJ,EAAKpB,EAAa,YAAc,QAyB1DoB,EAAKT,EAvBFY,EAAMQ,eAuBKD,WAwBAA,UAxBgBJ,MA4BjC,CACCM,YAAgB,KAAO,EAAInC,KAAKI,aAAkB,IAAMJ,KAAKI,QAI/D,IAAK,IAAIgC,EAAI,EAAGA,EAAIpC,KAAKM,EAAQ+B,OAAQD,IAAK,CAC7C,IAAME,EAAOtC,KAAKM,EAAQ8B,GAE1BjB,EAAST,KAAK4B,GACdtC,KAAKC,SAASsC,QAAQD,GAInBtC,KAAKG,GAAYH,KAAKC,SAASsC,QAAQvC,KAAKG,GAOhDH,KAAKc,EAAM,WAWZU,EAAA,WACC,IAAMgB,EAAgBC,OAAOC,YAEvBpB,EAAkBkB,EAAgBxC,KAAKK,EAG7C,OAFAL,KAAKK,EAAkBmC,EAEhBlB"}